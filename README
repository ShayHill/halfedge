A somewhat typical halfedges data structure.

The big difference is holes. A "triangle" mesh is 2D will never be entirely triangular (and also manifold). There will
be a boundary around the triangles. This module keeps track of these holes and tries to keep them out of your way.,

edge.hole may show a hole or face, but vert.faces and mesh.faces will not list holes. they should be safe to ignore.

A proper half-edge data structure stores:
    a set of verts (redundant)
    a set of edges
    for each edge, pointers to vert, pair, face, next
    a set of faces (redundant)
    for each vert, a pointer to an edge (redundant)
    for each face, a pointer to an edge (redundant)

This implementation only stores a set of edges. Sets of verts and faces are generated from iterating through references
in edge instances. Vert.edge references and face.edge references are found the same way. This makes for slower code,
but does not violate DRY and makes for dramatically cleaner code.

This means that verts and faces cannot do much if their associated edges have not been added to mesh.edges.

Also means that this won't be useful for more than hundreds (maybe thousands) of edges. Good enough for my purposes.

The only thing guaranteed besides connectivity is element sn. This allows code such as

    last_issued_sn = mesh.last_issued_sn
    # do some things
    new_edges = {x for x in mesh.edges if x.sn > last_issued_sn}

