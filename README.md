# A typical halfedges data structure with some padding

## Holes

A "triangle" mesh in 2D will never be entirely triangular (and also manifold). There will be a boundary around the triangles. This library treats the outside of that boundary as a face (with an `__is_hole == True` attribute). This way, every edge has a pair and a face, and the `__is_hole` flags can be used to keep these hole faces out of your way.

Holes are useful for more than just 2D mesh boundaries, you can explicitly create holes (`Face` instances with an as `__is_hole == True` property to maintain manifold mesh conditions in many circumstances. The constructor `HalfEdges.from_vlvi()` will try to insert hole faces to maintain manifold conditions.)

Four main types: Vert, Edge, Face, and HalfEdges. Vert and Face instances have `*.faces` properties which will return all adjacent faces. These properties will *not* return faces flagged as holes.

Vert and Face instances have
Faces flagged as holes will not appear under querries `vert.faces` or `mesh.faces`.
`edge.face` may show a hole or face, but `vert.faces` and `mesh.faces` will not list holes. In these cases, holes should be safe to ignore. 

A proper half-edge data structure stores:

* a set of verts (redundant)
* for each vert, a pointer to an edge
* a set of edges
* for each edge, pointers to vert, pair, face, next
* a set of faces (redundant)
* for each face, a pointer to an edge

This implementation only stores a set of edges. Sets of verts and faces are generated by iterating through references
in edge instances. This makes for slower code, but does not violate DRY and makes for dramatically cleaner code.

This means that verts and faces disappear from a mesh when the edges referencing them are removed.

Also means that this won't be useful for more than hundreds (maybe thousands) of edges. Good enough for my purposes.
